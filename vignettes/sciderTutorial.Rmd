---
title: "scider: Single-Cell Investigation of Donor Expression Reproducibility"
author: "Michael Cole"
date: "`r Sys.Date()`"
bibliography: bibFile.bib
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteEncoding{UTF-8}
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{scider Vignette}
-->

```{r options, include=FALSE, cache=FALSE, results='hide', message=FALSE}

knitr::opts_chunk$set(fig.align="center", cache=FALSE,error=FALSE,
                      fig.width=6,fig.height=6,autodep=TRUE,
                      out.width="600px", out.height="600px",
                      results="markup", echo=TRUE, eval=TRUE)

options(getClass.msg=FALSE)

set.seed(1237) ## for reproducibility

library(openxlsx)
library(scider)
library(SummarizedExperiment)
library(Rtsne)
library(RColorBrewer)
library(NMF)
library(igraph)
library(RCurl)
library(gdata)
library(biomaRt)
library(Biobase)
library(GEOquery)

```

# Introduction

As single-cell technologies mature and push the boundaries of study resolution 
and scale, they promise to enrich our understanding of many complex biological 
systems. In the human disease context, studies of single donors may prove very 
fruitful in the characterization and cataloging of diverse cell states. While 
single-subject studies can be used to generate bold hypotheses, these 
approaches do not guarantee results applicable to other people with related 
phenotype. If the goal of an analysis is to predict phenomena across a 
specific phenotype - in humans, mice, or other models - it is important
to prioritize reproducibility across multiple sources.

In this vignette we will step through an analysis of single-cell RNA-Seq data 
collected from 3 human donors. In Section 2, we model coarse-grained structures
in the expression data, discussing the problem of clustering cells across 
multiple donors. In Section 3, we begin to leverage donor information in order 
to identify "reproducible gene modules": axes of expression variation that are 
common to all donors. Section 4 introduces quantitative tools - based on the 
Irreproducible Discovery Rate [@li2011] - for assessing signal 
reproducibility across donors. Examples from differential expression analysis, 
differential signature analysis, and correlation analysis demonstrate the 
general applicability of the framework and utilities. Section 5 summarizes 
additional tools for meta-analysis applicable to multi-donor studies. Section 6
presents a simple tool for relating modules for the purpose of marker 
discovery.

## The Data Set: Dendritic Cells in Elite Controllers

Human systems typically exhibit a diversity of biological phenomena beyond the 
uncontrolled axes of variation seen in model organisms. Each donor is a complex
product of genetics, behavior, exposure and environment.

In this vignette, we consider a single-cell RNA-Seq data set of cells collected
from 3 Elite Controllers (ECs): HIV-infected individuals with vanishingly small
levels of circulating virus. In order to probe the nature of innate immune
responses in these subjects, donor dendritic cells were isolated and exposed to
pseudotyped HIV-1 for 48 hours. Other cells were exposed to a media control for
the same period of time.

```{r datain}

table_dir =  paste0(
  "~/Dropbox/",
  "2016 Gayo Single Cell DC HIV/",
  "NBT Submission/",
  "Submission Files/Tables/"
  )

# Load scRNA-Seq (Normalized and log-tranformed)
df_meta = read.xlsx(xlsxFile = paste0(table_dir,
                                 "Gayo_NBT_Table_S1.xlsx"))
df_expr = read.xlsx(xlsxFile = paste0(table_dir,
                                 "Gayo_NBT_Table_S2.xlsx"))

is_late = df_meta$timepoint == "48H"
donor = factor(df_meta$patient[is_late])
lexpr = t(as.matrix(df_expr[is_late,-1]))
colnames(lexpr) = df_expr[is_late,1]
lexpr = lexpr[apply(lexpr, 1, var) > 0, ]

```

# Clustering Across Donors

When performing single-cell analysis across multiple donors, it is often 
important to compare cells across them, i.e. quantify the extent to which 
samples from different donors contain cells that are representative of the 
"same" cell state. While there may be biologically meaningful differences in 
the expression profiles between similar cells collected from different 
subjects, characterizing those differences can be a challenging task, 
especially when cells occupy a high-dimensional expression manifold. For 
example, some cell states may be represented in greater or lesser number across
donors, and some cell states are unique to donors. Additionally, there may be 
batch effects due to subtle differences in extraction or sample processing. Any
effort to decouple these contributions requires careful consideration, and the 
data adjustments necessary for removing related technical artifacts are beyond
the scope of this vignette (for more info see the `scone` package on
[Bioconductor](http://bioconductor.org/packages/scone/)). The data in this
vignette has been normalized via quantile normalization, and a full discussion
of methods and motivations can be found in the supplementary text of Gayo et
al. 2017.

## PAM Clustering via Dimension Reduction

If expression data from multiple batches has been properly normalized, we may 
attempt to relate cell expression profiles to eachother based on their pairwise
distances. In high-dimensional data such as these, many axes of variation are 
random and noisy: they do not inform us of the underlying cell state. Dimension
reduction techniques such as Principal Components Analysis (PCA) allow us to 
represent the data with a smaller number of features with high signal-to-noise 
ratios. Distances computed on these features may be used partion or cluster
cells according to cell state. 

Partitioning Around Medoid (PAM) is a clustering algorithm that searches for a 
set of `k` medoids spanning the data set, mapping each cell to a cluster 
represented by the closest medoid. Because the number of clusters, `k`, is 
unspecified at the beginning of an analysis, it is common to choose a value of 
`k` that maximizes the "overall average silhoutte width": the average over all 
sample "silhouette" values, quantifying the extent to which a sample clusters 
with its own cluster over others. This procedure is implemented in `pamk`
exported by the `fpc` package.

The `pamkd` function, introduced here, performs Partitioning Around Medoid
(PAM) clustering over a range of clusters, similar to `pamk`, but it also
ranges over a range of principal components, varying the dimension over which
distances are computed. After clustering over a range of dimension, this
function selects a dimension for the data that maximizes the cluster number.

```{r cluster}

pamkd_obj = pamkd(
  lexpr,
  maxk = 10,
  maxd = 50,
  to_log = FALSE,
  pca_center = TRUE,
  pca_scale = TRUE
)

```

In the call above, we have set the following argument values:

* `maxk` = 10. Consider a maximum of 10 PAM clusters.
* `maxd` = 50. Consider a maximum of 50 Principal Components (PCs).
* `to_log` = FALSE. Data is already log-transformed.
* `pca_center` = TRUE. Expression data rows (genes) are centered for PCA.
* `pca_scale` = TRUE. Genes are scaled to unit variance for PCA.

Inspecting the output, under the `pamobject` return value, we see 
that `pamkd` identified 5 clusters across the 3 donors.

```{r cluster_show}

table(pamkd_obj$pamobject$clustering,
      donor)

```

Interestingly, only one cluster, cluster `3`, is unique to any donor; in other 
analyses there could be far more donor-specific clusters. Cells like cluster 3
may be present in other donors, and single-donor analyses could be used to
generate candidate markers for additional experimental exploration. However,
the focus of the present analysis is the space of reproducible phenomena.

Briefly note that selection of maximum values for either `k` or `d` should
raise doubts about the robustness of the results, as they could depend on our
choice of parameter ranges. One way to test this effect is to consider larger
values for `maxk` or `maxd`.

## Visualizing Results with tSNE

One advantage of the simultaneous `k` and `d` selection above is that we are 
left with a small number of PCs that are well-suited for non-linear dimension 
reduction techniques that are designed for visual representation (e.g. tSNE).

```{r tsne}

tsne_obj = Rtsne(pamkd_obj$Y,
                        pca = FALSE,
                        max_iter = 5000,
                        verbose = FALSE)

```

Because 7 PCs optimally resolved the five clusters reported by `pamkd`, we
expect further dimension reduction techniques to preserve that clustering.
Therefore tSNE may provides us with a 2-dimensional representation of
clustering in 7-dimensions. Below we can see that tSNE faithfully represents 
our clusters. In the plot below we have reordered cluster names to match the 
main manuscript.

```{r plottsne}

donor_pchs = c(21, 22, 24)
cluster_cols = c("turquoise1",
                 "darkolivegreen1",
                 "black",
                 "azure1",
                 "tomato1")

plot(
  tsne_obj$Y,
  xlim = c(-25, 25),
  ylim = c(-25, 25),
  pch = donor_pchs[as.numeric(donor)],
  bg = cluster_cols[pamkd_obj$pam$clustering],
  main = "DC Expression State Manifold at 48H",
  xlab = "tSNE Dim 1",
  ylab = "tSNE Dim 2"
)

legend("topright",
       pch = donor_pchs,
       legend = paste0("P", 1:3))

o = c(1, 3, 5, 4, 2) # Alternative cluster labels
clustering = paste0("c", o[pamkd_obj$pam$clustering])

legend(
  "bottomright",
  fill = cluster_cols[order(o)],
  legend = paste0("c", 1:5)
)
  
```

# Reproducible Gene Modules

Given access to multiple samples of homologous single-cell populations, it may 
be important to identify common sets of covarying genes or "reproducible gene 
modules." Reproducibly correlated gene modules may inform us of novel 
biological mechanisms in these systems.

If cell populations are heterogeneous, this kind of analysis may naturally 
follow a clustering step, uncovering reproducible modes of intra-cluster 
variation. Alternatively, reproducible correlation analysis may be done 
separately from clustering analysis altogether; reproducible modules can serve
as a basis for a reproducible inter-cluster manifold. We will consider this
latter approach in this section.

The `scider` package facilitates a three-step reproducible gene module
analysis. The first step involves identifying gene-gene pairs that are
"reproducibly correlated," generating a gene-gene adjacency matrix. We will
first consider a simple threshold-based reproducibility criterion and turn to
other options later in the vignette. The second step is hub-identification in
the reproducible gene-gene graph. The goal of this step is to identify genes
that play critical roles in the reproducible covariance structure. The third
step is the least critical, clustering hub genes into "reproducible modules."

## Defining a Reproducible Gene-Gene Adjacency Matrix

In the first step or our analysis, we use `get.repro.thresh.adjacency` to
generate a gene-gene adjacency matrix based on a simple correlation threshold
criterion.

```{r adj}

A = get.repro.thresh.adjacency(x = lexpr,
                               r = donor,
                               pair_pthresh = 0.01474)

```

In the call above, we have set the following argument values:

* `r` = donor. Correlation matrices will be separately computed across all
three donors.
* `pair_pthresh` = 0.01474. Following z-scaling of donor upper-triangular
correlation matrices, a pair will be called "reproducible" if its z-value 
corresponds to a 2-tailed p-value below this threshold. The unusual threshold
value - an artifact of an alternative transformation scheme - was selected to
perfectly reproduce the results in Gayo et al. 2017.

If a gene-pair's p-value falls below `pair_pthresh` in all donors, an
undirected edge is drawn between the two genes. Due to the small number edges
expected in this matrix, the result is returned in a sparse matrix format.

## Hub Identification

The `pzipdegree` function is a simple tool for hub identification based on a 
Poisson model of vertex degree: this degree distribution would result from 
independent and uniform edge probabilities in the case of many genes. Our model
includes a zero-inflated component to represent noisy genes with correlations 
consistently below threshold. `pzipdegree` takes an `igraph` object as its
argument, returning upper-tail p-values under the null model.

```{r hub}

g = graph.adjacency(A,mode = "undirected")
is_hub = p.adjust(pzipdegree(g), method = "bonferroni") < 0.01
table(is_hub)

```

Visualizing the subgraph of hubs below we can see that there is some
interesting structure.

```{r hub_show}

g_hub = graph.adjacency(A[is_hub,is_hub],mode = "undirected")

plot(g_hub, vertex.size = 5, vertex.color = "white",
     layout = layout.fruchterman.reingold(g_hub),
     vertex.label = "",
     vertex.shape = "circle",
     vertex.frame.color = "blue")

```

## Hub Clustering and Reproducible Module Annotation

In the last step of our reproducible module analysis, we aim to cluster hub 
genes into reproducible modules. `scider` provides no new tools for this step, 
but we may rely on other common libraries: there are many ways to cluster genes
based on their correlation sub-matrix. Below we have clustered according to a 
median hub-hub correlation matrix: the element-wise median of all
donor-specific hub-hub correlation matrices.

```{r hubclust}

# Compute hub-hub correlations per donor
rep_cor_list = sapply(levels(donor),
                      simplify = FALSE,
                      function(p) {
                        cor(t(lexpr[is_hub,
                              donor == p]))
                        })

# Median hub correlation matrix
mediancor = apply(simplify2array(rep_cor_list), 1:2, median)

# Median hub correlation matrix
hc = hclust(dist(1 - cor(mediancor,
                         method = "pearson")),
            method = "complete")
hub_clustering = factor(paste0("m",cutree(hc, k = 3)))

table(hub_clustering)

```

Setting the number of modules to three we find one large module and two smaller
modules. Visualizing the median correlation below, three appears to be a
reasonable selection of module number:

```{r mediancor}

module_cols <- brewer.pal(3, "Set1")

aheatmap(
  main = "Median Hub-Gene Correlations",
  mediancor,
  breaks = 0,
  annCol = list(Modules = hub_clustering),
  annColors = list(Modules = module_cols),
  distfun = "correlation",
  hclustfun = "complete"
)


```

Module `m1` is anti-correlated with both `m2` and `m3`, but `m3` forms a
uniform sub-module. When we visualize the three donor-specific correlation
matrices separately we can see that `m1` is very robust, while the contrast
between `m2` and `m3` softens between donors.

```{r donorcors}

hm_list = sapply(levels(donor),
       function(p) {
         aheatmap(
           main = paste("Hub-Gene Correlations in",p),
           rep_cor_list[[p]],
           breaks = 0,
           annCol = list(Modules = hub_clustering),
           annColors = list(Modules = module_cols),
           distfun = "correlation",
           hclustfun = "complete"
         )
       }
)

```

## Reproducible Inter-Cluster Manifold

As mentioned above, reproducible modules may be used to compare clusters within
a reproducible subspace. Below we define a simple module score to illustrate
this concept.

```{r module_scores}

# Define module score as mean of expression z-scores
module_scores = t(aggregate(t(apply(
  lexpr[is_hub, ], 1, scale
)),
by = list(hub_clustering),
FUN = mean)[, -1])

aheatmap(t(module_scores),
         main = "Reproducible Module Scores", labRow = levels(hub_clustering),
         breaks = 0, annCol = list(Clusters = clustering, Donors = donor),
         annRow = list(Modules = factor(levels(hub_clustering))),
         annColors = list(Clusters = cluster_cols[order(o)],
                          Donors = c("lightblue","violet","gold"),
                          Modules = module_cols)
  )


```

We can also visualize this three-dimensional data in a 2-dimensional
representation below.

```{r module_scores_tsne}
  
# 2D tSNE on module scores
tsne_obj_hub = Rtsne(module_scores,
                     pca = FALSE,
                     max_iter = 5000,
                     verbose = FALSE)

```

Below we can see that this "reproducible" tSNE manifold is different from the 
original above. There is a smoother transition from `c1` to `c2`, `c3`, and on 
to a merged `c4-5` cluster. This gradual progression is one motivation for
focusing on extremal clusters (not `c2`) for differential expression analysis.

```{r module_scores_tsne_show}

plot(
  tsne_obj_hub$Y,
  xlim = c(-25, 25),
  ylim = c(-25, 25),
  pch = donor_pchs[as.numeric(donor)],
  bg = cluster_cols[pamkd_obj$pam$clustering],
  main = "Reproducible DC Expression State Manifold at 48H",
  xlab = "tSNE Dim 1",
  ylab = "tSNE Dim 2"
)

legend("topright",
       pch = donor_pchs,
       legend = paste0("P", 1:3))

legend("bottomright",
       fill = cluster_cols[order(o)],
       legend = paste0("c", 1:5))

```

# Reproducibility-Based Differential Expression and Signature Analyses

At this point in our analysis, we are beginning to study gene-level phenomena. 
For example, we may start to quantify the extent to which transcripts are 
up-regulated or down-regulated in `c1` cells vs `c3-5` cells. How to we begin 
to address patient variability? For example, how do we address expression 
differences between `c1` cells across donors? In this section we will first 
consider a traditional method for modeling donor biases in the context of
differential expression. Then we will contrast modeling results to the results
of Irreproducible Discovery Rate (IDR) analysis as outlined in [@li2011],
taking the opportunity to discuss our contribution to pre-existing IDR tool
set.

Following our discussion of differential expression, we will demonstrate the 
generalizability of `scider` IDR tools by applying them to two different
signature analyses.

## Linear Models of Differential Expression

Our first method models the log-expression of each gene with gene-specific
linear models. For each gene we estimate a separate offset, cluster effect
(`c1` vs `c3-5`), and donor effects (`P1` or `P2` vs `P3`) to model the
expression of that gene across all cells in th study, excluding cells in `c2`.

```{r lm}

# Dependent and independent variables
is_included = !clustering %in% "c2"
x = lexpr[, is_included]
g = factor(c("c1",NA,rep("c3-5",3))[factor(clustering)])[is_included]
r = donor[is_included]

# One fit per gene
bio_effect_results = data.frame(t(apply(x, 1,function(y){
  coefficients(summary(lm(y ~ g + r)))["gc3-5",c("Estimate","Pr(>|t|)")]
  })),row.names = rownames(x))
colnames(bio_effect_results) = c("Estimate","p")

plot(-bio_effect_results$Estimate,
     -log10(bio_effect_results$p),
     main = "c1 vs c3-5: Donor-Adjusted Effect",
     xlab = "Effect", ylab = "-log10(p-value)",
     pch = 16, xlim = c(-8,8), ylim = c(0,150))
```

Given there are less than 10,000 tests, it is obvious that the p-value 
distribution is skewed heavily toward low values. This is not particularly 
suprising given that cell clustering is based on the expression data itself.

A notable limitation of this simple model is that it does not include 
interactions between donor and cluster: not only can there be no attribution of
donor-specific differential expression effect, but there is no notion of 
"common" effect being modeled. Rather than consider more sophisticated 
alternatives, we will explore how these results compare to those of IDR 
meta-analysis.

## Irreproducible Discovery Rate

Rather than simply identifying genes that show significant evidence of
differential expression, we may wish to emphasize differential expression that
is "reproducible" across donors. The Irreproducible Discovery Rate framework 
[@li2011] outlines methods for comparing results of replicate analyses: e.g. 
differential expression analyses performed separately for each donor. Given a 
list of significance scores (e.g. -log(p-value)), for each donor, we can fit 
tests to a 2-component mixture model: tests are either part of an 
irreproducible component, in which significance rank is uncorrelated across 
donors, or part of a reproducible component in which significance rank is 
correlated and higher on average.

`kruskalIDRm` is a function for stratified gene-level tests of association
(Kruskal-Wallis H test), followed by IDR analysis on the resulting
-log(p-value) matrix. Arguments to this function include:

* `x`: the (log-) expression matrix to be tested.
* `r`: replicate groups under which association tests are performed.
* `g`: groups of cells to be compared with respect to every gene.

Due to small numbers of cells in the first two donors, the analysis presented 
in our manuscript pooled cells from donors `P1` and `P2` in order to form two 
replicate groups: `P12` and `P3`. Note that IDR tools impemented in the CRAN 
[idr](https://cran.r-project.org/web/packages/idr/index.html) package are
designed to analyze only 2 replicates.

```{r idr2}

r = factor(c(rep("P12",2),"P3")[donor[is_included]])
idrm_kruskal_pool = kruskalIDRm(x, r, g)

```

The resulting list contains the (named) p-value matrix from differential
expression tests, an object containing all IDR results, and a logical
indicating which genes were included in the DE analysis; low-gene variance
genes are filtered at the earliest stage. We can access the gene-level IDR
estimates for all genes that were tested, by accessing the IDR analysis
element, `idr`:

```{r idr2_unpack}

IDR = idrm_kruskal_pool$idr$IDR
names(IDR) = rownames(
  idrm_kruskal_pool$kruskal_pvals)[idrm_kruskal_pool$is_replicated]

```

Similar to a false-discovery rate (FDR), IDR values correspond to the 
cumulative fraction of irreproducible tests (genes) for genes of less or equal 
irreproducible component membership probability.

Below we plot the relationship between IDR values and Bonferroni-adjusted
t-test p-values from the section above.

```{r idr2vpval}

lm_pvals_adjust = p.adjust(bio_effect_results[names(IDR),]$p,
                           method = "bonferroni")

gtype = factor(paste((-log10(lm_pvals_adjust) > 2), (-log10(IDR)  > 2)))
gcols = c("grey", "blue", "red", "purple")[gtype]

plot(
  -log10(lm_pvals_adjust),
  -log10(IDR),
  pch = 21,
  bg = gcols,
  main = "Differential Expression: c1 vs c3-5, per gene",
  xlab = "-log10(Bonferroni lm p-value)",
  ylab = "-log10(IDR): 2 Replicates (w/ Pooling)"
)
abline(v = 2, col = "red", lty = 2)
abline(h = 2, col = "blue", lty = 2)
legend(
  "bottomright",
  legend = paste(
    c("insig. irrep.", "insig. rep.", "sig. irrep.", "sig. rep."),
    "n =",
    table(gtype)
  ),
  fill = c("grey", "blue", "red", "purple")
)

```

We can see that 29% of the genes that are called as significantly 
differentially expressed (adjusted p-value < 0.01) are not reproducibly so (IDR
< 0.01). These genes are differentially expressed, but they do not vary 
consistently across the 2 cell pools. For example, a gene may be differentially
expressed in one but not the other. Alternatively, the gene could be
differentially expressed in both pools, but the rank of the difference
varies substantially between pools:

```{r pvalvpval_sig}

rank_matrix = apply(idrm_kruskal_pool$kruskal_pvals[names(IDR), ],
                    2, rank)
plot(
  rank_matrix[as.numeric(gtype) %in% c(3, 4), ],
  main = "Rank of p-value",
  pch = 16,
  cex = .5,
  xlim = range(rank_matrix),
  ylim =  range(rank_matrix),
  col = gcols[as.numeric(gtype) %in% c(3, 4)]
)
legend(
  "topright",
  legend =
    c("sig. irrep.", "sig. rep."),
  fill = c("red", "purple")
)

```

On the other hand, only 8% of genes that exhibit reproducible p-value rank fall
below our significance threshold. The presence of many tests like this could
suggest that the significance threshold is too stringent or that there is an
issue with the underlying null model used for computing p-values.

```{r pvalvpval_insig}

plot(
  rank_matrix[as.numeric(gtype) %in% c(1, 2), ],
  main = "Rank of p-value",
  pch = 16,
  cex = .5,
  xlim = range(rank_matrix),
  ylim =  range(rank_matrix),
  col = gcols[as.numeric(gtype) %in% c(1, 2)]
)
legend(
  "topright",
  legend =
    c("insig. irrep.", "insig. rep."),
  fill = c("grey", "blue")
)

```

Beyond the small number of insignificant reproducible tests, the IDR criterion 
appears to be be stricter than our significance criterion, selecting a smaller
set of tests with uniform results across replicate pools.

## Irreproducible Discovery Rate with Many Replicates

In the `scider` package we have modified code from the CRAN 
[idr](https://cran.r-project.org/web/packages/idr/index.html) package to handle
more than 2 replicates, as prescribed in the authors' original manuscript. The 
many-replicate `est.IDRm` function implemented in `scider` is adapted from the 
2-replicate `est.IDR` in `idr`, inlcuding some new error messages.

Using this broader functionality, we may choose to perform a similar analysis
as in the previous subsection, but treat each donor as a replicate pool.

```{r idr3}

r = donor[is_included]
idrm_kruskal = kruskalIDRm(x, r, g)

```

How do results change when treating `P1` and `P2` as replicate pools? Due to
gene filtering, there may be a few genes that are absent from the 3-way
analysis; we will only consider the intersection of genes from both.

```{r idr3_unpack}

# Unpacking IDR values for many replicates
IDRm = idrm_kruskal$idr$IDR
names(IDRm) = rownames(idrm_kruskal$kruskal_pvals)[idrm_kruskal$is_replicated]

# Subsetting IDR values over shared tests
genes_shared = intersect(names(IDR), names(IDRm))
IDR = IDR[genes_shared]
IDRm = IDRm[genes_shared]

```

Below we plot log-transformed IDR values from both analyses:

```{r idrvidr}

gtype0 = factor(paste((-log10(IDR) > 2), (-log10(IDRm)  > 2)))
gcols0 = c("grey", "blue", "red", "purple")[gtype0]

plot(
  -log10(IDR),
  -log10(IDRm),
  pch = 21,
  bg = gcols0,
  main = "Differential Expression: c1 vs c3-5, per gene",
  xlab = "-log10(IDR): 2 Replicates (w/ Pooling)",
  ylab = "-log10(IDR): 3 Replicates (w/o Pooling)"
)
abline(v = 2, col = "red", lty = 2)
abline(h = 2, col = "blue", lty = 2)
abline(0, 1, lty = 2, col = "black")
legend(
  "topleft",
  legend = paste(
    c("irrep2, irrep3", "irrep2, rep3", "rep3, irrep2", "rep2, rep3"),
    "n =",
    table(gtype0)
  ),
  fill = c("grey", "blue", "red", "purple")
)

```

Above we can see that there are slightly more reproducible tests called in the 
3-way analysis. Notice also that the most reproducible tests are assigned 
greater membership probability to the reproducible component in the new 
analysis.

## Other Extensions to IDR Analysis

In addition to high-level functions such as `kruskalIDRm`, `scider` implements 
new tools for probing lower-level IDR analysis. It was mentioned above that 
`est.IDRm` is the underlying function behind IDR analysis in `scider`. The 
arguments to this function include a matrix of signals, and initialized 
parameter values for the underlying fit. Consider signals from the
three-replicate analysis above: log-transformed p-value from gene-level
Kruskal-Wallis tests. With `est.IDRm` we can reproduce the IDR values of this
analysis exactly:

```{r lowlevel}

signals = -log10(na.omit(idrm_kruskal$kruskal_pvals))

idr = est.IDRm(
  signals,
  mu = 2, sigma = 2, rho = 0.5, p = 0.01)

print(all(idrm_kruskal$idr$IDR == idr$IDR))

```


```{r sample}

idr_sample = est.IDRm.sample(x = signals,
                             frac = 0.7,
                             nsamp = 10,
                             mu = 1, sigma = 0.5,
                             rho = 0.7, p = 0.05)

bxp(idr_sample$para_bp, ylim = c(0,3), main = "Fit Parameter Values")
points(unlist(idr$para), pch = 4, col = "red")

```

```{r sample_show}

plot(idr_sample$mean_idr,idr_sample$sd_idr,
     xlab = "Mean Irrep. Membership",
     ylab = "Standard Deviation of Irrep. Membership")

```
## Other IDR Applications: Identification of upstream regulators

The IDR framework can be applied to many other kinds of signals.
Table S2. Normalized mRNA counts and associated significant hits obtained
from knockdown of 6 known and 17 candidate signaling regulators, and 121
transcriptional regulators. The "Normalized" sheet shows the normalized mRNA
counts for the 128-target genes (including 10 control genes; rows) upon
knockdown of indicated genes (columns).
Table S7. Normalized mRNA counts and associated significant hits obtained
from knockdown of 11 Plk-dependent phosphoproteins. The "Normalized" sheet
shows the normalized mRNA counts for the 128-target genes (including 10
control genes; rows) upon knockdown of indicated genes (columns).

```{r get_chev}

urls = paste(paste0("http://www.ncbi.nlm.nih.gov/pmc/articles/",
  "PMC3809888/bin/NIHMS350287-supplement-Table"),
  c("S2.xls", "S7.xls"), sep = "_")
sheet_index = c(2, 3)
shrna_counts = do.call(cbind, 
                       lapply(1:2, function(s) {
                         df = read.xls(urls[s], sheet = sheet_index[s])
                         x = as.matrix(df[,-1])
                         rownames(x) = df$Target_genes
                         x}))

aheatmap(
  log1p(shrna_counts),
  main = paste("Normalized mRNA log-counts across",
               ncol(shrna_counts),
               "shRNA knockdowns")
  )

```

```{r map_chev}

gene_map = getLDS(
  mart = useMart("ENSEMBL_MART_ENSEMBL", 
                dataset = "mmusculus_gene_ensembl",
                host = "jul2015.archive.ensembl.org"),
  attributes = "mgi_symbol",
  filters = "mgi_symbol", values = rownames(shrna_counts),
  martL = useMart("ENSEMBL_MART_ENSEMBL", 
                dataset = "hsapiens_gene_ensembl",
                host = "jul2015.archive.ensembl.org"),
  attributesL = "hgnc_symbol",
  filtersL = "hgnc_symbol", valuesL = rownames(lexpr)
)

# Select expression sub-matrices for uniquely mapped genes
uniq_gene_map = gene_map[apply(apply(gene_map,2,isUnique),1,all), ]
sc_expr = lexpr[uniq_gene_map$HGNC.symbol, ]
shrna_expr = log(shrna_counts + 1)[uniq_gene_map$MGI.symbol, ]

```

```{r prep_chev}

upstream_scores = -cor(shrna_expr - rowMeans(shrna_expr),
    sc_expr - rowMeans(sc_expr))

aheatmap(
  upstream_scores,
  annCol = list(clustering),annColors = list(cluster_cols[order(o)]),
  breaks = 0,
  main = paste("(Unweighted) Upstream Regulatory Scores for",
               ncol(shrna_counts),
               "shRNA knockdowns")
  )


```


```{r idr_chev}

is_included = !clustering %in% "c2"
x = upstream_scores[, is_included]
g = factor(c("c1", NA, rep("c3-5", 3))[factor(clustering)])[is_included]
r = factor(c(rep("P12", 2), "P3")[donor[is_included]])
idrm_kruskal_pool_shrna = kruskalIDRm(x, r, g)

mean_sigs = aggregate(t(x), by = list(cluster = g, pool = r), FUN = mean)
lfc = colMeans(mean_sigs[, -c(1:2)][mean_sigs$cluster == "c1", ] -
                 mean_sigs[, -c(1:2)][mean_sigs$cluster != "c1", ])

plot(
  lfc[rownames(idrm_kruskal_pool_shrna$kruskal_pvals)],
  -log10(idrm_kruskal_pool_shrna$idr$IDR),
  pch = 21,
  bg = 1 + (idrm_kruskal_pool_shrna$idr$IDR < 0.05),
  main = paste("shRNA Analysis: c1 vs c3-5"),
  ylab = "-log10(IDR)",
  xlim = c(-0.5, 0.5),
  ylim = c(0, 2),
  xlab = "Mean Difference in Upstream Regulatory Score"
)

abline(h = -log10(0.05),
       lty = 2,
       col = 2)

# Label Tbk1
is_tbk1 = rownames(idrm_kruskal_pool_shrna$kruskal_pvals) == "Tbk1"
tbk1_x = lfc[rownames(idrm_kruskal_pool_shrna$kruskal_pvals)][is_tbk1]
tbk1_y = -log10(idrm_kruskal_pool_shrna$idr$IDR)[is_tbk1]
lines(c(tbk1_x,tbk1_x + 0.15),c(tbk1_y,tbk1_y))
points(tbk1_x,tbk1_y,pch = 21,bg = 2)
text(pos = 4,tbk1_x+ 0.15,tbk1_y,labels = "Tbk1")

```

# Other Meta-Analysis Utilities

```{r get_tlr}

# Download GEO Data
options('download.file.method' = 'curl')
geo_set = getGEO("GSE17721")[[1]]

# Aggregate by sample biotype and gene symbol
meta_data = t(simplify2array(strsplit(as.character(geo_set$title),
                                      split = ", ")))
bio_type = factor(gsub("ontrol", "",
                      paste0(meta_data[, 1], gsub(
                      "_.*", "", meta_data[, 2]
                      ))))
gene_symbol = factor(featureData(geo_set)$"Gene Symbol")

tlr_array = t(aggregate(t(aggregate(
  exprs(geo_set), by = list(gene_symbol), mean
  )[, -1]), by = list(bio_type), mean)[, -1])
dimnames(tlr_array) = list(levels(gene_symbol), levels(bio_type))
  
# Identify unambiguous gene symbol designations
ambiguous_symbols = unique(unlist(strsplit(levels(gene_symbol)[grepl(" /// ",
                                                      levels(gene_symbol))],
                                                  split = " /// ")))
tlr_array = tlr_array[!rownames(tlr_array) %in% ambiguous_symbols,]

# Select 0-hour control and 24-hour perturbations
tlr_array  = tlr_array [, grepl("[^C]24|C0", colnames(tlr_array))]

aheatmap(
  log1p(tlr_array),
  main = paste("Normalized mRNA log-abundance across",
               ncol(tlr_array),
               "bulk samples")
  )
```

```{r map_tlr}
gene_map = getLDS(
  mart = useMart("ENSEMBL_MART_ENSEMBL",
                 dataset = "mmusculus_gene_ensembl",
                 host = "jul2015.archive.ensembl.org"),
  attributes = "mgi_symbol",
  filters = "mgi_symbol",
  values = rownames(tlr_array),
  martL = useMart("ENSEMBL_MART_ENSEMBL",
                  dataset = "hsapiens_gene_ensembl",
                  host = "jul2015.archive.ensembl.org"),
  attributesL = "hgnc_symbol",
  filtersL = "hgnc_symbol",
  valuesL = rownames(lexpr)
)

# Select expression sub-matrices for uniquely mapped genes
uniq_gene_map = gene_map[apply(apply(gene_map, 2, isUnique), 1, all),]
is_withinrange = uniq_gene_map$MGI.symbol %in% rownames(tlr_array) &
  uniq_gene_map$HGNC.symbol %in% rownames(lexpr)
uniq_gene_map = uniq_gene_map[is_withinrange, ]

sc_expr = lexpr[uniq_gene_map$HGNC.symbol,]
tlr_expr = log(tlr_array)[uniq_gene_map$MGI.symbol,]

```

```{r prep_tlr}

stim_scores = cor(tlr_expr - rowMeans(tlr_expr),
                 sc_expr - rowMeans(sc_expr))

aheatmap(
  stim_scores,
  annCol = list(clustering),annColors = list(cluster_cols[order(o)]),
  breaks = 0,
  main = paste("(Unweighted) TLR Stimulation Scores for",
               nrow(stim_scores),
               "Bulk Samples")
  )
```

```{r meta_tlr}

is_included = !clustering %in% "c2"
x = stim_scores[, is_included]
g = factor(c("c1", NA, rep("c3-5", 3))[factor(clustering)])[is_included]
r = factor(c(rep("P12", 2), "P3")[donor[is_included]])
meta_kruskal_pool_tlr = kruskalMeta(x, r, g)

mean_sigs = aggregate(t(x), by = list(cluster = g, pool = r), FUN = mean)
lfc = colMeans(mean_sigs[, -c(1:2)][mean_sigs$cluster == "c1", ] -
                 mean_sigs[, -c(1:2)][mean_sigs$cluster != "c1", ])

is_sig = meta_kruskal_pool_tlr$FDR < 0.001

plot(
  lfc[rownames(meta_kruskal_pool_tlr$kruskal_pvals)],
  -log10(meta_kruskal_pool_tlr$FDR),
  pch = 21,
  bg = 1 + is_sig,
  main = paste("TLR Analysis: c1 vs c3-5"),
  ylab = "-log10(FDR)",
  xlim = c(-0.1, 0.1),
  ylim = c(0, 20),
  xlab = "Mean Difference in TLR Stimulation Score"
)

abline(h = -log10(0.001),
       lty = 2,
       col = 2)

# Labels
text(lfc[rownames(meta_kruskal_pool_tlr$kruskal_pvals)][is_sig],
  -log10(meta_kruskal_pool_tlr$FDR)[is_sig],
  pos = 3,
  labels = names(which(is_sig)))

```

```{r meta_tlr2}

is_included = clustering %in% "c1"
x0 = stim_scores[, is_included]["C0",]
x = stim_scores[, is_included][-which(rownames(stim_scores) == "C0"),]
r = factor(c(rep("P12",2),"P3")[donor[is_included]])

# CDFs
for (p in levels(r)) {
  is_p = r == p
  plot(ecdf(x0[is_p]), main = paste0("c1 in ",p),
       xlab = "x = TLR Stimulation Score",
       do.points=FALSE, verticals = TRUE, lwd = 3,xlim = range(rbind(x0,x)))
  for(i in 1:nrow(x)){
    plot(ecdf(x[i,][is_p]), do.points=FALSE,
         verticals = TRUE,
         add=TRUE, col=brewer.pal(nrow(x),"Set1")[i], lwd = 3)
  }
  legend("bottomright",legend = rownames(x),lty = 1,
         lwd = 3,col = brewer.pal(nrow(x),"Set1"))
  legend("topleft",legend = "Control",col = 1, lty = 1, lwd = 3)
}

```

```{r meta_tlr2_test}

meta_ks_pool_tlr = ksMeta(x,x0,r)
stopifnot(all(meta_ks_pool_tlr$is_replicated))

mean_sigs = aggregate(t(x), by = list(pool = r), FUN = mean)
mean_sigs0 = aggregate(x0, by = list(pool = r), FUN = mean)
lfc = colMeans(mean_sigs[,-1] - mean_sigs0[,-1])

is_sig = meta_ks_pool_tlr$FDR < 0.001
  
plot(
  lfc,
  -log10(meta_ks_pool_tlr$FDR),
  pch = 21,
  bg = 1 + is_sig,
  main = paste("TLR Analysis: c1 Similarity"),
  ylab = "-log10(FDR)",
  xlim = c(-0.1, 0.1),
  ylim = c(0, 20),
  xlab = "Mean Difference TLR Stimulation Score vs Control Score"
)

abline(h = -log10(0.001),
       lty = 2,
       col = 2)

# Label Tbk1
text(lfc[is_sig],
  -log10(meta_ks_pool_tlr$FDR)[is_sig],
  pos = 3,
  labels = names(which(is_sig)))

```

# Marker Prediction

In the main manuscript we describe why differentially-expressed hub genes are 
good biomarker candidates. The `getMarkers` function is a wrapper for IDR-based
differential expression analysis and reproducible hub identification. The code
below can be used to reproduce the marker prediction from our main analysis.

```{r markers}

x = lexpr
g = factor(c("c1",NA,rep("c3-5",3))[factor(clustering)])
r = donor
r_de = factor(c(rep("P12",2),"P3")[donor])

search_page = "http://www.proteinatlas.org/search"
search_terms = "protein_class%3APredicted+membrane+proteins"
query_format = "format=tab"
dbdat = read.table(
  paste0(search_page,"/",search_terms,"?",query_format),
           sep = "\t",quote = "", header = TRUE)

external_markers = intersect(as.character(dbdat$Gene),rownames(x))
markers = getMarkers(x = x, r = r, r_de = r_de, pair_pthresh = 0.01474,
                 g = g, g_target = "c1",
                 external_markers = external_markers,
                 plot_venn = TRUE)


```

# Session Info

```{r session}
sessionInfo()
```