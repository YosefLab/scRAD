---
title: "scider: Single-Cell Investigation of Donor Expression Reproducibility"
author: "Michael Cole"
date: "`r Sys.Date()`"
bibliography: bibFile.bib
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteEncoding{UTF-8}
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{scider Vignette}
-->

```{r options, include=FALSE, cache=FALSE, results='hide', message=FALSE}

knitr::opts_chunk$set(fig.align="center", cache=FALSE,error=FALSE,
                      fig.width=6,fig.height=6,autodep=TRUE,
                      out.width="600px", out.height="600px",
                      results="markup", echo=TRUE, eval=TRUE)

options(getClass.msg=FALSE)

set.seed(1237) ## for reproducibility

library(openxlsx)
library(scider)
library(SummarizedExperiment)
library(Rtsne)
library(RColorBrewer)
library(NMF)
library(igraph)
library(RCurl)
library(gdata)
library(biomaRt)
library(Biobase)
library(GEOquery)

```

# Introduction

As single-cell technologies mature and push the boundaries of study resolution 
and scale, they promise to enrich our understanding of many complex biological 
systems. In the human disease context, studies of single donors may prove very 
fruitful in the characterization and cataloging of diverse cell states. While 
single-subject studies can be used to generate bold hypotheses, these 
approaches do not guarantee results applicable to other people with related 
phenotype. If the goal of an analysis is to predict phenomena across a 
specific phenotype - in humans, mice, or other models - it is important
to prioritize reproducibility across multiple sources.

In this vignette we will step through an analysis of single-cell RNA-Seq data 
collected from 3 human donors. In Section 2, we model coarse-grained structures
in the expression data, discussing the problem of clustering cells across 
multiple donors. In Section 3, we begin to leverage donor information in order 
to identify "reproducible gene modules": axes of expression variation that are 
common to all patients. Section 4 introduces quantitative tools - based on the 
Irreproducible Discovery Rate [@li2011] - for assessing signal 
reproducibility across donors. Examples from differential expression analysis, 
differential signature analysis, and correlation analysis demonstrate the 
general applicability of the framework and utilities. Section 5 summarizes 
additional tools for meta-analysis applicable to multi-donor studies. Section 6
presents a simple tool for relating modules for the purpose of marker 
discovery.

## The Data Set: Dendritic Cells in Elite Controllers

Human systems typically exhibit a diversity of biological phenomena beyond the 
uncontrolled axes of variation seen in model organisms. Each donor is a complex
product of genetics, behavior, exposure and environment.

In this vignette, we consider a single-cell RNA-Seq data set of cells collected
from 3 Elite Controllers (ECs): HIV-infected individuals with vanishingly small
levels of circulating virus. In order to probe the nature of innate immune
responses in these subjects, donor dendritic cells were isolated and exposed to
pseudotyped HIV-1 for 48 hours. Other cells were exposed to a media control for
the same period of time.

```{r datain}

table_dir =  paste0(
  "~/Dropbox/",
  "2016 Gayo Single Cell DC HIV/",
  "NBT Submission/",
  "Submission Files/Tables/"
  )

# Load scRNA-Seq (Normalized and log-tranformed)
df_meta = read.xlsx(xlsxFile = paste0(table_dir,
                                 "Gayo_NBT_Table_S1.xlsx"))
df_expr = read.xlsx(xlsxFile = paste0(table_dir,
                                 "Gayo_NBT_Table_S2.xlsx"))

is_late = df_meta$timepoint == "48H"
donor = factor(df_meta$patient[is_late])
lexpr = t(as.matrix(df_expr[is_late,-1]))
colnames(lexpr) = df_expr[is_late,1]
lexpr = lexpr[apply(lexpr, 1, var) > 0, ]

```

# Clustering Across Donors

When performing single-cell analysis across multiple donors, it is often 
important to compare cells across them - i.e. quantify the extent to which 
samples from different donors are representative of the "same" cell state. This
can be a challenging task, especially when cells occupy a high-dimensional 
expression manifold: there may be biologically meaningful differences in the 
expression profiles between similar cells collected from different subjects. 
Additionally there may be batch effects due to subtle differences in extraction
or sample processing; data adjustments for removing these technical artifacts 
(e.g. normalization) are beyond the scope of this vignette (for more info see 
the `scone` package on 
[Bioconductor](http://bioconductor.org/packages/scone/)).

## PAM Clustering via Dimension Reduction

`pamkd` performs Partitioning Around Medoid (PAM) clustering over a range of
cluster number following Principal Components Analysis (PCA). By clustering
over a range of dimension, this function selects a dimension for the data that
maximizes the cluster number.

```{r cluster}

pamkd_obj = pamkd(
  lexpr,
  maxk = 10,
  maxd = 50,
  to_log = FALSE,
  pca_center = TRUE,
  pca_scale = TRUE
)

```

In the call above, we have set the following parameters:

* maxk = 10. Consider a maximum of 10 PAM clusters. 
* maxd = 50. Consider a maximum of 50 Principal Components.
* to_log = FALSE. Data is already log-transformed.
* pca_center = TRUE. Expression data rows (genes) are centered prior to SVD.
* pca_scale = TRUE. Genes are scaled to unit variance prior to SVD.

Looking at the resulting output, under the `pamobject` return value, we see
that we have identified 5 clusters across the 3 patients. 

```{r cluster_show}

table(pamkd_obj$pamobject$clustering,
      donor)

```

Note that only one cluster, cluster `3`, is unique to any donor. In other 
analyses there could be far more donor-specific clusters. In those cases,
expert knowledge and/or sophisticated normalization techniques may be necessary
to merge clusters across subjects.

## Visualizing Results with tSNE

One advantage of the simultaneous `k` and `d` selection above is that we are
left with a small number of Principal Components (PCs) that are well-suited for
non-linear dimension reduction techniques such a tSNE.

```{r tsne}

tsne_obj = Rtsne(pamkd_obj$Y,
                        pca = FALSE,
                        max_iter = 5000,
                        verbose = FALSE)

```

Because these PCs were sufficient in resolving the five clusters, we expect 
that faithful dimension reduction should preserve the clustering. In the plot
below we have reordered cluster names to match the main manuscript.

```{r plottsne}

donor_pchs = c(21, 22, 24)
cluster_cols = c("turquoise1",
                 "darkolivegreen1",
                 "black",
                 "azure1",
                 "tomato1")

plot(
  tsne_obj$Y,
  xlim = c(-25, 25),
  ylim = c(-25, 25),
  pch = donor_pchs[as.numeric(donor)],
  bg = cluster_cols[pamkd_obj$pam$clustering],
  main = "DC Expression State Manifold at 48H",
  xlab = "tSNE Dim 1",
  ylab = "tSNE Dim 2"
)

legend("topright",
       pch = donor_pchs,
       legend = paste0("P", 1:3))

o = c(1, 3, 5, 4, 2) # Alternative cluster labels
clustering = paste0("c", o[pamkd_obj$pam$clustering])

legend(
  "bottomright",
  fill = cluster_cols[order(o)],
  legend = paste0("c", 1:5)
)
  
```

# Reproducible Gene Modules

Given access to multiple samples of homologous single-cell populations, it may 
be important to identify sets of genes that vary across all of them. This kind 
of analysis may naturally follow a clustering step, uncovering reproducible 
modes of intra-cluster variation. Alternatively, this analysis may be done 
separately from clustering analysis; reproducible modules varying across all 
cells in the population serve as a basis for a reproducible inter-cluster 
manifold. We take this latter approach in this vignette.

Our reproducible gene module analysis is broken into three steps:

1) Identify gene-gene pairs that are reproducibly correlated above a threshold.
2) Identify "hubs" in the reproducible gene-gene graph.
3) Cluster hub genes into reproducible modules.

## Defining a Reproducible Gene-Gene Adjacency Matrix

The `get.repro.thresh.adjacency` can generate a gene-gene adjacency matrix
based on a simple correlation threshold criterion.

```{r adj}

A = get.repro.thresh.adjacency(x = lexpr,
                               r = donor,
                               pair_pthresh = 0.01474)

```

For each donor, Pearson correlations are computed across all gene pairs.
Resulting pairs are Fisher-transformed, centered and scaled to unit variance
over the upper-triangular. The choice of `pair_pthresh` corresponds to the
maximum 2-tailed p-value under a normal null. If a gene-pair falls below this
threshold in all donors, an undirected edge is drawn between the two genes.

## Hub Identification

The `pzipdegree` is a simple tool for hub identification based on a Poisson 
model of vertex degree. The model includes a zero-inflated component to 
represent noisy genes with correlations consistently below threshold. The
method returns upper-tail p-values for ranking hub genes under the null model.

```{r hub}

g = graph.adjacency(A,mode = "undirected")
is_hub = p.adjust(pzipdegree(g), method = "bonferroni") < 0.01

```

Visualizing the largest component of the graph, we can see that these hub genes
(red points) cluster into multiple "reproducible modules".

```{r hub_show}

g_hub = graph.adjacency(A[is_hub,is_hub],mode = "undirected")

plot(g_hub, vertex.size = 5, vertex.color = "white",
     layout = layout.fruchterman.reingold(g_hub),
     vertex.label = "",
     vertex.shape = "circle",
     vertex.frame.color = "blue")

```

## Module Clustering

In the final step of our reproducible module analysis, we aim to cluster hub
genes into reproducible modules. There are many ways to cluster genes, but
below we have clustered according to a median hub correlation matrix: the
element-wise median of all donor-specific hub-hub correlation matrices.

```{r hubclust}

# Compute hub-hub correlations per donor
rep_cor_list = sapply(levels(donor),
                      simplify = FALSE,
                      function(p) {
                        cor(t(lexpr[is_hub,
                              donor == p]))
                        })

# Median hub correlation matrix
mediancor = apply(simplify2array(rep_cor_list), 1:2, median)

# Median hub correlation matrix
hc = hclust(dist(1 - cor(mediancor,
                         method = "pearson")),
            method = "complete")
hub_clustering = factor(paste0("m",cutree(hc, k = 3)))

table(hub_clustering)

```

Setting the number of module to three we find one large module and two smaller
modules. We can visualize the median correlation below:

```{r mediancor}

module_cols <- brewer.pal(3, "Set1")

aheatmap(
  main = "Median Hub-Gene Correlations",
  mediancor,
  breaks = 0,
  annCol = list(Modules = hub_clustering),
  annColors = list(Modules = module_cols),
  distfun = "correlation",
  hclustfun = "complete"
)


```

From the hierarchical clustering, module `m1` is anti-correlated with both `m2`
and `m3`, but `m3` forms a uniform sub-module. When we visualize the three
donor-specific correlation matrices separately we can see that `m1` is very
robust, while the contrast between `m2` and `m3` softens between donors.

```{r donorcors}

hm_list = sapply(levels(donor),
       function(p) {
         aheatmap(
           main = paste("Hub-Gene Correlations in",p),
           rep_cor_list[[p]],
           breaks = 0,
           annCol = list(Modules = hub_clustering),
           annColors = list(Modules = module_cols),
           distfun = "correlation",
           hclustfun = "complete"
         )
       }
)

```

## Reproducible Inter-Cluster Manifold

As mentioned above, reproducible modules may be used to compare clusters within
a reproducible subspace. In this section we will define simple module scores
and use these as the basis of a tSNE representation:

```{r module_scores}

# Define module score as mean of expression z-scores
module_scores = t(aggregate(t(apply(
  lexpr[is_hub, ], 1, scale
)),
by = list(hub_clustering),
FUN = mean)[, -1])

# 2D tSNE on module scores
tsne_obj_hub = Rtsne(module_scores,
                     pca = FALSE,
                     max_iter = 5000,
                     verbose = FALSE)

```

Below we can see that this "reproducible" tSNE manifold is different from the 
original above. There is a smoother transition from `c1` to `c2`, `c3`, and on 
to a merged `c4-5` cluster. This gradual progression motivates our focus on
extremal clusters (not `c2`) for differential expression analysis.

```{r module_scores_show}

plot(
  tsne_obj_hub$Y,
  xlim = c(-25, 25),
  ylim = c(-25, 25),
  pch = donor_pchs[as.numeric(donor)],
  bg = cluster_cols[pamkd_obj$pam$clustering],
  main = "Reproducible DC Expression State Manifold at 48H",
  xlab = "tSNE Dim 1",
  ylab = "tSNE Dim 2"
)

legend("topright",
       pch = donor_pchs,
       legend = paste0("P", 1:3))

legend("bottomright",
       fill = cluster_cols[order(o)],
       legend = paste0("c", 1:5))

```

# Irreproducible Discovery Rate and Differential Expression

Below we will consider three methods for calling differential expression
between `c1` cells and `c3-5` cells.

NOTE: POWER ANALYSIS NOTE: Simulations for interaction NOTE: Like some feedback
from other people in the lab

## Ordinary Least-Squares Regression with donor Term

Our first method is based on a simple regression model. For each gene we
estimate a separate offset, cluster effect (`c1` vs `c3-5`), and donor
effects (`P1`/`P2` vs `P3`) to model the expression of that gene across all
cells in th study.

```{r lm}

is_included = !clustering %in% "c2"
x = lexpr[, is_included]
g = factor(c("c1",NA,rep("c3-5",3))[factor(clustering)])[is_included]

# List: One lm fit per gene
lm_list = apply(
  lexpr[, is_included], 1,
  function(y) {
    lm(y ~ g + factor(donor[is_included],
                      levels = c("P3", "P1", "P2")))
    })

# Matrix of t-test p-values
lm_pvals  = unlist(lapply(lm_list, function(x) {
  coefficients(summary(x))[2, 4]
}))

# Top 
plot(seq_along(lm_pvals)/(length(lm_pvals)+1),
     sort(lm_pvals),
     main = "DE: donor-Adjusted P-value",
     xlab = "Theoretical Quantiles",
     ylab = "Observed Quantiles",
     log = "xy")
abline(0,1, lty = 2)

```

Obviously the p-value distribution is skewed heavily to low values. This is not
particularly suprising given that the clustering is based on the expression 
data itself. One problem with this simple model is that it does not accomodate
interactions: there is no attribution of donor-specific differential
expression.

## Irreproducible Discovery Rate

Rather than simply identifying genes that show evidence of differential 
expression, we may wish to emphasize differential expression that is 
"reproducible" across donors. The Irreproducible Discovery Rate framework 
(NOTE: CITE) offers methods for comparing results of replicate analyses: e.g. 
differential expression analyses performed separately for each donor. Given a 
list of significance scores (e.g. -log(p-value)), for each donor, we can fit 
tests to a 2-component mixture model: tests are either part of an
irreproducible component, in which significance rank is uncorrelated across
donors, or part of a reproducible component in which significance rank is
correlated and higher on average.

`kruskalIDRm` is a wrapper function for gene-level tests of association
(Kruskal-Wallis rank sum), followed by IDR analysis on the resulting
-log(p-value) matrix. In order to call this function, a user must specify
replicate groups under which association tests are performed. The analysis
presented in our manuscript pooled cells from donors `P1` and `P2` to form
two replicate groups: `P12` and `P3`.

```{r idr2}

r = factor(c(rep("P12",2),"P3")[donor[is_included]])
idrm_kruskal_pool = kruskalIDRm(x, r, g)

```

The resulting list contains the p-value matrix from differential expression 
tests, an object containing all IDR results, and a logical indicating which 
genes were included in the DE analysis; low-gene variance genes are filtered at
the earliest stage. We can access the gene-level IDR estimates for all genes
that were tested:

```{r idr2_unpack}

IDR = idrm_kruskal_pool$idr$IDR
names(IDR) = rownames(
  idrm_kruskal_pool$kruskal_pvals)[idrm_kruskal_pool$is_replicated]

```

Similar to a false-discovery rate (FDR), these values correspond to the
cumulative fraction of irreproducible tests (genes) for genes of less or equal 
irreproducible component membership probability.

Below we plot the relationship between IDR values and adjusted t-test p-values
from the section above.

```{r idr2vpval}

lm_pvals_adjust = p.adjust(lm_pvals[names(IDR)], method = "bonferroni")

gtype = factor(paste((-log10(lm_pvals_adjust) > 2), (-log10(IDR)  > 2)))
gcols = c("grey", "blue", "red", "purple")[gtype]

plot(
  -log10(lm_pvals_adjust),
  -log10(IDR),
  pch = 21,
  bg = gcols,
  main = "Differential Expression: c1 vs c3-5, per gene",
  xlab = "-log10(Bonferroni DE p-value); all samples w/batch term",
  ylab = "-log10(IDR): 2 Replicates (w/ Pooling)"
)
abline(v = 2, col = "red", lty = 2)
abline(h = 2, col = "blue", lty = 2)
legend(
  "bottomright",
  legend = paste(
    c("no sig. no rep.", "no sig. rep.", "sig. no rep.", "sig. rep."),
    "n =",
    table(gtype)
  ),
  fill = c("grey", "blue", "red", "purple")
)

```

We can see that 29% of the genes that are called as significantly 
differentially expressed (adjusted p-value < 0.01) are not reproducibly so (IDR
< 0.01). On the other hand, only 8% of reproducible tests do not meet the 
traditional significance threshold. Therefore, the reproducible criterion 
appears to be be stricter in addition to being more easily interpretable.

## Irreproducible Discovery Rate with Many Replicates

In this package we have modified the code from the CRAN 
[idr](https://cran.r-project.org/web/packages/idr/index.html) package to handle
more than 2 replicates, as discussed in the authors' original manuscript (NOTE:
CITE). Using this functionality, we may choose to perform a similar analysis as
in the previous subsection, but treat each donor as a replicate pool.

```{r idr3}

r = donor[is_included]
idrm_kruskal = kruskalIDRm(x, r, g)

```

Now we may consider the difference in treating `P1` and `P2` as replicate
pools. Due to gene filtering, there may be a few genes that are absent from the
3-way analysis.

```{r idr3_unpack}

# Unpacking IDR values for many replicates
IDRm = idrm_kruskal$idr$IDR
names(IDRm) = rownames(idrm_kruskal$kruskal_pvals)[idrm_kruskal$is_replicated]

# Subsetting IDR values over shared tests
gnoms = intersect(names(IDR), names(IDRm))
IDR = IDR[gnoms]
IDRm = IDRm[gnoms]

```

Below we plot log-transformed IDR values from both analyses.

```{r idrvidr}

gtype0 = factor(paste((-log10(IDR) > 2), (-log10(IDRm)  > 2)))
gcols0 = c("grey", "blue", "red", "purple")[gtype0]

plot(
  -log10(IDR),
  -log10(IDRm),
  pch = 21,
  bg = gcols0,
  main = "Differential Expression: c1 vs c3-5, per gene",
  xlab = "-log10(IDR): 2 Replicates (w/ Pooling)",
  ylab = "-log10(IDR): 3 Replicates (w/o Pooling)"
)
abline(v = 2, col = "red", lty = 2)
abline(h = 2, col = "blue", lty = 2)
abline(0, 1, lty = 2, col = "black")
legend(
  "topleft",
  legend = paste(
    c("no rep2, no rep3", "no rep2, rep3", "rep3, no rep2", "rep2, rep3"),
    "n =",
    table(gtype0)
  ),
  fill = c("grey", "blue", "red", "purple")
)

```

We can see from this plot that there are slightly more reproducible tests 
called in the 3-way analysis. Notice also that the most reproducible tests are
assigned greater membership probability to the reproducible component in the
new analysis.

## Extensions of IDR Analysis

## Other IDR Applications: Identification of upstream regulators

The IDR framework can be applied to many other kinds of signals. 
Table S2. Normalized mRNA counts and associated significant hits obtained
from knockdown of 6 known and 17 candidate signaling regulators, and 121
transcriptional regulators. The "Normalized" sheet shows the normalized mRNA
counts for the 128-target genes (including 10 control genes; rows) upon
knockdown of indicated genes (columns).
Table S7. Normalized mRNA counts and associated significant hits obtained
from knockdown of 11 Plk-dependent phosphoproteins. The "Normalized" sheet
shows the normalized mRNA counts for the 128-target genes (including 10
control genes; rows) upon knockdown of indicated genes (columns).

```{r get_chev}

urls = paste(paste0("http://www.ncbi.nlm.nih.gov/pmc/articles/",
  "PMC3809888/bin/NIHMS350287-supplement-Table"),
  c("S2.xls", "S7.xls"), sep = "_")
sheet_index = c(2, 3)
shrna_counts = do.call(cbind, 
                       lapply(1:2, function(s) {
                         df = read.xls(urls[s], sheet = sheet_index[s])
                         x = as.matrix(df[,-1])
                         rownames(x) = df$Target_genes
                         x}))

aheatmap(
  log1p(shrna_counts),
  main = paste("Normalized mRNA log-counts across",
               ncol(shrna_counts),
               "shRNA knockdowns")
  )

```

```{r map_chev}

gene_map = getLDS(
  mart = useMart("ENSEMBL_MART_ENSEMBL", 
                dataset = "mmusculus_gene_ensembl",
                host = "jul2015.archive.ensembl.org"),
  attributes = "mgi_symbol",
  filters = "mgi_symbol", values = rownames(shrna_counts),
  martL = useMart("ENSEMBL_MART_ENSEMBL", 
                dataset = "hsapiens_gene_ensembl",
                host = "jul2015.archive.ensembl.org"),
  attributesL = "hgnc_symbol",
  filtersL = "hgnc_symbol", valuesL = rownames(lexpr)
)

# Select expression sub-matrices for uniquely mapped genes
uniq_gene_map = gene_map[apply(apply(gene_map,2,isUnique),1,all), ]
sc_expr = lexpr[uniq_gene_map$HGNC.symbol, ]
shrna_expr = log(shrna_counts + 1)[uniq_gene_map$MGI.symbol, ]

```

```{r prep_chev}

upstream_scores = -cor(shrna_expr - rowMeans(shrna_expr),
    sc_expr - rowMeans(sc_expr))

aheatmap(
  upstream_scores,
  annCol = list(clustering),annColors = list(cluster_cols[order(o)]),
  breaks = 0,
  main = paste("(Unweighted) Upstream Regulatory Scores for",
               ncol(shrna_counts),
               "shRNA knockdowns")
  )


```


```{r idr_chev}

is_included = !clustering %in% "c2"
x = upstream_scores[, is_included]
g = factor(c("c1", NA, rep("c3-5", 3))[factor(clustering)])[is_included]
r = factor(c(rep("P12", 2), "P3")[donor[is_included]])
idrm_kruskal_pool_shrna = kruskalIDRm(x, r, g)

mean_sigs = aggregate(t(x), by = list(cluster = g, pool = r), FUN = mean)
lfc = colMeans(mean_sigs[, -c(1:2)][mean_sigs$cluster == "c1", ] -
                 mean_sigs[, -c(1:2)][mean_sigs$cluster != "c1", ])

plot(
  lfc[rownames(idrm_kruskal_pool_shrna$kruskal_pvals)],
  -log10(idrm_kruskal_pool_shrna$idr$IDR),
  pch = 21,
  bg = 1 + (idrm_kruskal_pool_shrna$idr$IDR < 0.05),
  main = paste("shRNA Analysis: c1 vs c3-5"),
  ylab = "-log10(IDR)",
  xlim = c(-0.5, 0.5),
  ylim = c(0, 2),
  xlab = "Mean Difference in Upstream Regulatory Score"
)

abline(h = -log10(0.05),
       lty = 2,
       col = 2)

# Label Tbk1
is_tbk1 = rownames(idrm_kruskal_pool_shrna$kruskal_pvals) == "Tbk1"
tbk1_x = lfc[rownames(idrm_kruskal_pool_shrna$kruskal_pvals)][is_tbk1]
tbk1_y = -log10(idrm_kruskal_pool_shrna$idr$IDR)[is_tbk1]
lines(c(tbk1_x,tbk1_x + 0.15),c(tbk1_y,tbk1_y))
points(tbk1_x,tbk1_y,pch = 21,bg = 2)
text(pos = 4,tbk1_x+ 0.15,tbk1_y,labels = "Tbk1")

```

# Other Meta-Analysis Utilities

```{r get_tlr}

# Download GEO Data
options('download.file.method' = 'curl')
geo_set = getGEO("GSE17721")[[1]]

# Aggregate by sample biotype and gene symbol
meta_data = t(simplify2array(strsplit(as.character(geo_set$title),
                                      split = ", ")))
bio_type = factor(gsub("ontrol", "",
                      paste0(meta_data[, 1], gsub(
                      "_.*", "", meta_data[, 2]
                      ))))
gene_symbol = factor(featureData(geo_set)$"Gene Symbol")

tlr_array = t(aggregate(t(aggregate(
  exprs(geo_set), by = list(gene_symbol), mean
  )[, -1]), by = list(bio_type), mean)[, -1])
dimnames(tlr_array) = list(levels(gene_symbol), levels(bio_type))
  
# Identify unambiguous gene symbol designations
ambiguous_symbols = unique(unlist(strsplit(levels(gene_symbol)[grepl(" /// ",
                                                      levels(gene_symbol))],
                                                  split = " /// ")))
tlr_array = tlr_array[!rownames(tlr_array) %in% ambiguous_symbols,]

# Select 0-hour control and 24-hour perturbations
tlr_array  = tlr_array [, grepl("[^C]24|C0", colnames(tlr_array))]

aheatmap(
  log1p(tlr_array),
  main = paste("Normalized mRNA log-abundance across",
               ncol(tlr_array),
               "bulk samples")
  )
```

```{r map_tlr}
gene_map = getLDS(
  mart = useMart("ENSEMBL_MART_ENSEMBL",
                 dataset = "mmusculus_gene_ensembl",
                 host = "jul2015.archive.ensembl.org"),
  attributes = "mgi_symbol",
  filters = "mgi_symbol",
  values = rownames(tlr_array),
  martL = useMart("ENSEMBL_MART_ENSEMBL",
                  dataset = "hsapiens_gene_ensembl",
                  host = "jul2015.archive.ensembl.org"),
  attributesL = "hgnc_symbol",
  filtersL = "hgnc_symbol",
  valuesL = rownames(lexpr)
)

# Select expression sub-matrices for uniquely mapped genes
uniq_gene_map = gene_map[apply(apply(gene_map, 2, isUnique), 1, all),]
is_withinrange = uniq_gene_map$MGI.symbol %in% rownames(tlr_array) &
  uniq_gene_map$HGNC.symbol %in% rownames(lexpr)
uniq_gene_map = uniq_gene_map[is_withinrange, ]

sc_expr = lexpr[uniq_gene_map$HGNC.symbol,]
tlr_expr = log(tlr_array)[uniq_gene_map$MGI.symbol,]

```

```{r prep_tlr}

stim_scores = cor(tlr_expr - rowMeans(tlr_expr),
                 sc_expr - rowMeans(sc_expr))

aheatmap(
  stim_scores,
  annCol = list(clustering),annColors = list(cluster_cols[order(o)]),
  breaks = 0,
  main = paste("(Unweighted) TLR Stimulation Scores for",
               nrow(stim_scores),
               "Bulk Samples")
  )
```

```{r meta_tlr}

is_included = !clustering %in% "c2"
x = stim_scores[, is_included]
g = factor(c("c1", NA, rep("c3-5", 3))[factor(clustering)])[is_included]
r = factor(c(rep("P12", 2), "P3")[donor[is_included]])
meta_kruskal_pool_tlr = kruskalMeta(x, r, g)

mean_sigs = aggregate(t(x), by = list(cluster = g, pool = r), FUN = mean)
lfc = colMeans(mean_sigs[, -c(1:2)][mean_sigs$cluster == "c1", ] -
                 mean_sigs[, -c(1:2)][mean_sigs$cluster != "c1", ])

is_sig = meta_kruskal_pool_tlr$FDR < 0.001

plot(
  lfc[rownames(meta_kruskal_pool_tlr$kruskal_pvals)],
  -log10(meta_kruskal_pool_tlr$FDR),
  pch = 21,
  bg = 1 + is_sig,
  main = paste("TLR Analysis: c1 vs c3-5"),
  ylab = "-log10(FDR)",
  xlim = c(-0.1, 0.1),
  ylim = c(0, 20),
  xlab = "Mean Difference in TLR Stimulation Score"
)

abline(h = -log10(0.001),
       lty = 2,
       col = 2)

# Labels
text(lfc[rownames(meta_kruskal_pool_tlr$kruskal_pvals)][is_sig],
  -log10(meta_kruskal_pool_tlr$FDR)[is_sig],
  pos = 3,
  labels = names(which(is_sig)))

```

```{r meta_tlr2}

is_included = clustering %in% "c1"
x0 = stim_scores[, is_included]["C0",]
x = stim_scores[, is_included][-which(rownames(stim_scores) == "C0"),]
r = factor(c(rep("P12",2),"P3")[donor[is_included]])

# CDFs
for (p in levels(r)) {
  is_p = r == p
  plot(ecdf(x0[is_p]), main = paste0("c1 in ",p),
       xlab = "x = TLR Stimulation Score",
       do.points=FALSE, verticals = TRUE, lwd = 3,xlim = range(rbind(x0,x)))
  for(i in 1:nrow(x)){
    plot(ecdf(x[i,][is_p]), do.points=FALSE,
         verticals = TRUE,
         add=TRUE, col=brewer.pal(nrow(x),"Set1")[i], lwd = 3)
  }
  legend("bottomright",legend = rownames(x),lty = 1,
         lwd = 3,col = brewer.pal(nrow(x),"Set1"))
  legend("topleft",legend = "Control",col = 1, lty = 1, lwd = 3)
}

```

```{r meta_tlr2_test}

meta_ks_pool_tlr = ksMeta(x,x0,r)
stopifnot(all(meta_ks_pool_tlr$is_replicated))

mean_sigs = aggregate(t(x), by = list(pool = r), FUN = mean)
mean_sigs0 = aggregate(x0, by = list(pool = r), FUN = mean)
lfc = colMeans(mean_sigs[,-1] - mean_sigs0[,-1])

is_sig = meta_ks_pool_tlr$FDR < 0.001
  
plot(
  lfc,
  -log10(meta_ks_pool_tlr$FDR),
  pch = 21,
  bg = 1 + is_sig,
  main = paste("TLR Analysis: c1 Similarity"),
  ylab = "-log10(FDR)",
  xlim = c(-0.1, 0.1),
  ylim = c(0, 20),
  xlab = "Mean Difference TLR Stimulation Score vs Control Score"
)

abline(h = -log10(0.001),
       lty = 2,
       col = 2)

# Label Tbk1
text(lfc[is_sig],
  -log10(meta_ks_pool_tlr$FDR)[is_sig],
  pos = 3,
  labels = names(which(is_sig)))

```

# Marker Prediction

In the main manuscript we describe why differentially-expressed hub genes are 
good biomarker candidates. The `getMarkers` function is a wrapper for IDR-based
differential expression analysis and reproducible hub identification. The code
below can be used to reproduce the marker prediction from our main analysis.

```{r markers}

x = lexpr
g = factor(c("c1",NA,rep("c3-5",3))[factor(clustering)])
r = donor
r_de = factor(c(rep("P12",2),"P3")[donor])

search_page = "http://www.proteinatlas.org/search"
search_terms = "protein_class%3APredicted+membrane+proteins"
query_format = "format=tab"
dbdat = read.table(
  paste0(search_page,"/",search_terms,"?",query_format),
           sep = "\t",quote = "", header = TRUE)

external_markers = intersect(as.character(dbdat$Gene),rownames(x))
markers = getMarkers(x = x, r = r, r_de = r_de, pair_pthresh = 0.01474,
                 g = g, g_target = "c1",
                 external_markers = external_markers,
                 plot_venn = TRUE)


```

# Session Info

```{r session}
sessionInfo()
```