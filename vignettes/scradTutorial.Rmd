---
title: "scRAD: Single-Cell Reproducibility Across Donors"
author: "Michael Cole"
date: "`r Sys.Date()`"
bibliography: bibFile.bib
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteEncoding{UTF-8}
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{scone Vignette}
-->

```{r options, include=FALSE, cache=FALSE, results='hide', message=FALSE}

knitr::opts_chunk$set(fig.align="center", cache=FALSE,error=FALSE,
                      fig.width=6,fig.height=6,autodep=TRUE,
                      out.width="600px", out.height="600px",
                      results="markup", echo=TRUE, eval=TRUE)

options(getClass.msg=FALSE)

set.seed(1237) ## for reproducibility

library(scrad)
library(SummarizedExperiment)
library(Rtsne)
library(RColorBrewer)
library(NMF)
library(igraph)

```

# Introduction

As single-cell technologies mature and push the boundaries of study resolution 
and scale, they promise to enrich our understanding of many complex biological 
systems. In the human disease context, studies of single donors can prove very 
fruitful in the characterization and cataloging of diverse cell states. Of 
course, while single-subject studies can be used to generate bold hypotheses, 
this approach does not guarantee that results are relevant to people with 
related phenotypes. If the goal of an analysis is to predict phenomena across a
specific phenotype, it is important to prioritize reproducibility across 
multiple donors.

In this vignette we will step through an analysis of single-cell RNA-Seq data 
collected from 3 human donors, demonstrating how the principle of 
reproducibility can guide the computational analysis and how we can treat it
quantitatively within the frameworks of Reproducible Module Analysis or the 
Irreproducible Discovery Rate (IDR; NOTE:CITE).

## Dendritic Cells in Elite Controllers

As non-model organisms, humans are extremely difficult to study. Human systems
can exhibit extremely diverse biological phenomena, each a complex product of
genetics, behavior, exposure and environment.

In this vignette we consider a data set of cells collected from 3 Elite
Controllers (ECs). Some of the cells have been exposed to pseudotyped HIV-1 for
48 hours, while the rest have been exposed to a media control for the same
period of time.

NOTE:THESE FILES ARE NOT PART OF THE PACKAGE (YET)

```{r datain}

# Load scRNA-Seq (Normalized and log-tranformed)
load(file = "~/Dropbox/2016 Gayo Single Cell DC HIV/Analysis/normleDat.Rda")

# Rename Patients
colData(normleDat)$patient = c(1, 3, 2)[colData(normleDat)$patient]
colData(normleDat)$patient = factor(paste0("P",colData(normleDat)$patient))

# Select 48 Hour Cells
normleDat_late = normleDat[, colData(normleDat)$timepoint == "48H"]
normleDat_late = normleDat_late[apply(assay(normleDat_late), 1, var) > 0, ]

```

# Clustering Across Patients

When performing single-cell analysis across multiple donors, it is often 
important to compare cells across them - i.e. quantify the extent to which 
samples from different donors are representative of the "same" cell state. This
can be a challenging task, especially when cells occupy a high-dimensional 
expression manifold: there may be biologically meaningful differences in the 
expression profiles between similar cells collected from different subjects. 
Additionally there may be batch effects due to subtle differences in extraction
or sample processing; data adjustments for removing these technical artifacts 
(e.g. normalization) are beyond the scope of this vignette (for more info see 
the `scone` package on 
[Bioconductor](http://bioconductor.org/packages/scone/)).

## PAM Clustering via Dimension Reduction

`pamkd` performs Partitioning Around Medoid (PAM) clustering over a range of
cluster number following Principal Components Analysis (PCA). By clustering
over a range of dimension, this function selects a dimension for the data that
maximizes the cluster number.

```{r cluster}

pamkd_obj = pamkd(
  assay(normleDat_late),
  maxk = 10,
  maxd = 50,
  to_log = FALSE,
  pca_center = TRUE,
  pca_scale = TRUE
)

```

In the call above, we have set the following parameters:

* maxk = 10. Consider a maximum of 10 PAM clusters. 
* maxd = 50. Consider a maximum of 50 Principal Components.
* to_log = FALSE. Data is already log-transformed.
* pca_center = TRUE. Expression data rows (genes) are centered prior to SVD.
* pca_scale = TRUE. Genes are scaled to unit variance prior to SVD.

Looking at the resulting output, under the `pamobject` return value, we see
that we have identified 5 clusters across the 3 patients. 

```{r cluster_show}

table(pamkd_obj$pamobject$clustering,
      colData(normleDat_late)$patient)

```

Note that only one cluster, cluster `3`, is unique to any patient. In other 
analyses there could be far more donor-specific clusters. In those cases,
expert knowledge and/or sophisticated normalization techniques may be necessary
to merge clusters across subjects.

## Visualizing Results with tSNE

One advantage of the simultaneous `k` and `d` selection above is that we are
left with a small number of Principal Components (PCs) that are well-suited for
non-linear dimension reduction techniques such a tSNE.

```{r tsne}

tsne_obj = Rtsne(pamkd_obj$Y,
                        pca = FALSE,
                        max_iter = 5000,
                        verbose = FALSE)

```

Because these PCs were sufficient in resolving the five clusters, we expect 
that faithful dimension reduction should preserve the clustering. In the plot
below we have reordered cluster names to match the main manuscript.

```{r plottsne}

patient_pchs = c(21, 22, 24)
cluster_cols = c("turquoise1",
                 "darkolivegreen1",
                 "black",
                 "azure1",
                 "tomato1")

plot(
  tsne_obj$Y,
  xlim = c(-25, 25),
  ylim = c(-25, 25),
  pch = patient_pchs[as.numeric(colData(normleDat_late)$patient)],
  bg = cluster_cols[pamkd_obj$pam$clustering],
  main = "DC Expression State Manifold at 48H",
  xlab = "tSNE Dim 1",
  ylab = "tSNE Dim 2"
)

legend("topright",
       pch = patient_pchs,
       legend = paste0("P", 1:3))

o = c(1, 3, 5, 4, 2) # Alternative cluster labels
clustering = paste0("c", o[pamkd_obj$pam$clustering])

legend(
  "bottomright",
  fill = cluster_cols[order(o)],
  legend = paste0("c", 1:5)
)
  
```

# Reproducible Gene Modules

Given access to multiple samples of homologous single-cell populations, it may 
be important to identify sets of genes that vary across all of them. This kind 
of analysis may naturally follow a clustering step, uncovering reproducible 
modes of intra-cluster variation. Alternatively, this analysis may be done 
separately from clustering analysis; reproducible modules varying across all 
cells in the population serve as a basis for a reproducible inter-cluster 
manifold. We take this latter approach in this vignette.

Our reproducible gene module analysis is broken into three steps:

1) Identify gene-gene pairs that are reproducibly correlated above a threshold.
2) Identify "hubs" in the reproducible gene-gene graph.
3) Cluster hub genes into reproducible modules.

## Defining a Reproducible Gene-Gene Adjacency Matrix

The `get.repro.thresh.adjacency` can generate a gene-gene adjacency matrix
based on a simple correlation threshold criterion.

```{r adj}

A = get.repro.thresh.adjacency(x = assay(normleDat_late),
                               r = colData(normleDat_late)$patient,
                               pair_pthresh = 0.01474)

```

For each patient, Pearson correlations are computed across all gene pairs.
Resulting pairs are Fisher-transformed, centered and scaled to unit variance
over the upper-triangular. The choice of `pair_pthresh` corresponds to the
maximum 2-tailed p-value under a normal null. If a gene-pair falls below this
threshold in all patients, an undirected edge is drawn between the two genes.

## Hub Identification

The `pzipdegree` is a simple tool for hub identification based on a Poisson 
model of vertex degree. The model includes a zero-inflated component to 
represent noisy genes with correlations consistently below threshold. The
method returns upper-tail p-values for ranking hub genes under the null model.

```{r hub}

g = graph.adjacency(A,mode = "undirected")
is_hub = p.adjust(pzipdegree(g), method = "bonferroni") < 0.01

```

Visualizing the largest component of the graph, we can see that these hub genes
(red points) cluster into multiple "reproducible modules".

```{r hub_show}

g_list = decompose(g)
g_big = g_list[order(sapply(g_list,vcount),decreasing = TRUE)][[1]]
is_hub_big = V(g_big)$name %in% names(which(is_hub)) 
plot(g_big,vertex.size = 1, vertex.color = "red",
     layout = layout_nicely(g_big),
     vertex.label = "",
     vertex.shape = c("none","circle")[1 + is_hub_big],
     vertex.frame.color = "red")

```

## Module Clustering

In the final step of our reproducible module analysis, we aim to cluster hub
genes into reproducible modules. There are many ways to cluster genes, but
below we have clustered according to a median hub correlation matrix: the
element-wise median of all patient-specific hub-hub correlation matrices.

```{r hubclust}

# Compute hub-hub correlations per patient
rep_cor_list = sapply(levels(colData(normleDat_late)$patient),
                      simplify = FALSE,
                      function(p) {
                        cor(t(assay(normleDat_late)[is_hub,
                              colData(normleDat_late)$patient == p]))
                        })

# Median hub correlation matrix
mediancor = apply(simplify2array(rep_cor_list), 1:2, median)

# Median hub correlation matrix
hc = hclust(dist(1 - cor(mediancor,
                         method = "pearson")),
            method = "complete")
hub_clustering = factor(paste0("m",cutree(hc, k = 3)))

table(hub_clustering)

```

Setting the number of module to three we find one large module and two smaller
modules. We can visualize the median correlation below:

```{r mediancor}

module_cols <- brewer.pal(3, "Set1")

aheatmap(
  main = "Median Hub-Gene Correlations",
  mediancor,
  breaks = 0,
  annCol = list(Modules = hub_clustering),
  annColors = list(Modules = module_cols),
  distfun = "correlation",
  hclustfun = "complete"
)


```

From the hierarchical clustering, module `m1` is anti-correlated with both `m2`
and `m3`, but `m3` forms a uniform sub-module. When we visualize the three
patient-specific correlation matrices separately we can see that `m1` is very
robust, while the contrast between `m2` and `m3` softens between patients.

```{r patientcors}

hm_list = sapply(levels(colData(normleDat_late)$patient),
       function(p) {
         aheatmap(
           main = paste("Hub-Gene Correlations in",p),
           rep_cor_list[[p]],
           breaks = 0,
           annCol = list(Modules = hub_clustering),
           annColors = list(Modules = module_cols),
           distfun = "correlation",
           hclustfun = "complete"
         )
       }
)

```

## Reproducible Inter-Cluster Manifold

As mentioned above, reproducible modules may be used to compare clusters within
a reproducible subspace. In this section we will define simple module scores
and use these as the basis of a tSNE representation:

```{r module_scores}

# Define module score as mean of expression z-scores
module_scores = t(aggregate(t(apply(
  assay(normleDat_late)[is_hub, ], 1, scale
)),
by = list(hub_clustering),
FUN = mean)[, -1])

# 2D tSNE on module scores
tsne_obj_hub = Rtsne(module_scores,
                     pca = FALSE,
                     max_iter = 5000,
                     verbose = FALSE)

```

Below we can see that this "reproducible" tSNE manifold is different from the 
original above. There is a smoother transition from `c1` to `c2`, `c3`, and on 
to a merged `c4-5` cluster. This gradual progression motivates our focus on
extremal clusters (not `c2`) for differential expression analysis.

```{r module_scores_show}

plot(
  tsne_obj_hub$Y,
  xlim = c(-25, 25),
  ylim = c(-25, 25),
  pch = patient_pchs[as.numeric(colData(normleDat_late)$patient)],
  bg = cluster_cols[pamkd_obj$pam$clustering],
  main = "Reproducible DC Expression State Manifold at 48H",
  xlab = "tSNE Dim 1",
  ylab = "tSNE Dim 2"
)

legend("topright",
       pch = patient_pchs,
       legend = paste0("P", 1:3))

legend("bottomright",
       fill = cluster_cols[order(o)],
       legend = paste0("c", 1:5))

```

# Irreproducible Discovery Rate and Differential Expression

Below we will consider three methods for calling differential expression between `c1` cells and `c3-5` cells.

NOTE: POWER ANALYSIS
NOTE: Simulations for interaction
NOTE: Like some feedback from other people in the lab

## Ordinary Least-Squares Regression with Patient Term

Our first method is based on a simple regression model. For each gene we estimate a separate offset, cluster effect (`c1` vs `c3-5`), and patient effects (`P1`/`P2` vs `P3`) to model the expression of that gene across all cells in th study.

```{r lm}

is_included = !clustering %in% "c2"
x = assay(normleDat_late)[, is_included]
g = factor(c("c1",NA,rep("c3-5",3))[factor(clustering)])[is_included]

# List: One lm fit per gene
lm_list = apply(
  assay(normleDat_late)[, is_included], 1,
  function(y) {
    lm(y ~ g + factor(colData(normleDat_late)$patient[is_included],
                      levels = c("P3", "P1", "P2")))
    })

# Matrix of t-test p-values
lm_pvals  = unlist(lapply(lm_list, function(x) {
  coefficients(summary(x))[2, 4]
}))

# Top 
plot(seq_along(lm_pvals)/(length(lm_pvals)+1),
     sort(lm_pvals),
     main = "DE: Patient-Adjusted P-value",
     xlab = "Theoretical Quantiles",
     ylab = "Observed Quantiles",
     log = "xy")
abline(0,1, lty = 2)

```

Obviously the p-value distribution is skewed heavily to low values. This is not
particularly suprising given that the clustering is based on the expression 
data itself. One problem with this simple model is that it does not accomodate
interactions: there is no attribution of patient-specific differential
expression.

```{r idr2}

r = factor(c(rep("P12",2),"P3")[colData(normleDat_late)$patient[is_included]])
idrm_kruskal_pool = kruskalIDRm(x, r, g)

```

```{r idr2vpval}

IDR = idrm_kruskal_pool$idr$IDR
names(IDR) = rownames(idrm_kruskal_pool$kruskal_pvals)[idrm_kruskal_pool$is_replicated]

lm_pvals_adjust = p.adjust(lm_pvals[names(IDR)], method = "bonferroni")

gtype = factor(paste((-log10(lm_pvals_adjust) > 2), (-log10(IDR)  > 2)))
gcols = c("grey", "blue", "red", "purple")[gtype]

plot(
  -log10(lm_pvals_adjust),
  -log10(IDR),
  pch = 21,
  bg = gcols,
  main = "Differential Expression: c1 vs c3-5, per gene",
  xlab = "-log10(Bonferroni DE p-value); all samples w/batch term",
  ylab = "-log10(IDR): 2 Replicates (w/ Pooling)"
)
abline(v = 2, col = "red", lty = 2)
abline(h = 2, col = "blue", lty = 2)
legend(
  "bottomright",
  legend = paste(
    c("no sig. no rep.", "no sig. rep.", "sig. no rep.", "sig. rep."),
    "n =",
    table(gtype)
  ),
  fill = c("grey", "blue", "red", "purple")
)

```

```{r idr3}

r = colData(normleDat_late)$patient[is_included]
idrm_kruskal = kruskalIDRm(x, r, g)

```

```{r idrvidr}

IDR = idrm_kruskal_pool$idr$IDR
names(IDR) = rownames(idrm_kruskal_pool$kruskal_pvals)[idrm_kruskal_pool$is_replicated]

IDRm = idrm_kruskal$idr$IDR
names(IDRm) = rownames(idrm_kruskal$kruskal_pvals)[idrm_kruskal$is_replicated]

gnoms = intersect(names(IDR), names(IDRm))
IDR = IDR[gnoms]
IDRm = IDRm[gnoms]

gtype0 = factor(paste((-log10(IDR) > 2), (-log10(IDRm)  > 2)))
gcols0 = c("grey", "blue", "red", "purple")[gtype0]

plot(
  -log10(IDR),
  -log10(IDRm),
  pch = 21,
  bg = gcols0,
  main = "Differential Expression: c1 vs c3-5, per gene",
  xlab = "-log10(IDR): 2 Replicates (w/ Pooling)",
  ylab = "-log10(IDR): 3 Replicates (w/o Pooling)"
)
abline(v = 2, col = "red", lty = 2)
abline(h = 2, col = "blue", lty = 2)
abline(0, 1, lty = 2, col = "black")
legend(
  "topleft",
  legend = paste(
    c("no rep2, no rep3", "no rep2, rep3", "rep3, no rep2", "rep2, rep3"),
    "n =",
    table(gtype0)
  ),
  fill = c("grey", "blue", "red", "purple")
)

```

# Marker

NOTE: Intersect markers with rownames

```{r markers}

x = assay(normleDat_late)
g = factor(c("c1",NA,rep("c3-5",3))[factor(clustering)])
r = colData(normleDat_late)$patient
r_de = factor(c(rep("P12",2),"P3")[colData(normleDat_late)$patient])

search_page = "http://www.proteinatlas.org/search"
search_terms = "protein_class%3APredicted+membrane+proteins"
query_format = "format=tab"
dbdat = read.table(
  paste0(search_page,"/",search_terms,"?",query_format),
           sep = "\t",quote = "", header = TRUE)

markers = getMarkers(x = x, r = r, r_de = r_de, pair_pthresh = 0.01474,
                 g = g, g_target = "c1",
                 external_markers = as.character(dbdat$Gene),
                 plot_venn = TRUE)


```

# Session Info

```{r session}
sessionInfo()
```